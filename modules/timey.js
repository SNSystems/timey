/*eslint quotes: ["error", "single"]*/
'use strict';

const async = require ('async');
const cli_progress = require ('cli-progress');
const fs = require ('fs');
const glob = require ('glob-promise');
const os = require ('os');
const path = require ('path');
const {promisify} = require ('util');

const linkers = {rld: 1, lld: 2};
Object.freeze (linkers);
exports.linkers = linkers;

function get_key_by_value (object, value) {
    return Object.keys (object).find (key => object[key] === value);
}

/**
 * @param work_dir{string}  The directory used for intermediate files.
 * @returns {string} A glob pattern which will match the ticket files generated by rld-gen.
 */
function all_tickets_pattern (work_dir) {
    return path.join (work_dir, '*.o');
}

const object_file_extension = '.elf';

function all_objects_pattern (work_dir) {
    return path.join (work_dir, '*.o' + object_file_extension);
}

/**
 * Deletes the intermediate ticket, ELF, and repo database files from the working directory.
 *
 * @param work_dir{string}  The directory which will be used for intermediate files.
 * @param repo_name{string}  The name of the program repository database.
 * @returns {Promise<*>} A promise which is resolved once all of the intermediate files have been
 * deleted.
 */
function clean_all (work_dir, repo_name) {
    const clean = (pattern) => {
        return glob (pattern)
            .then ((contents) => contents.forEach (file => fs.unlinkSync (file)));
    };
    return clean (all_tickets_pattern (work_dir))
        .then (() => clean (path.join (work_dir, '*.o.elf')))
        .then (() => clean (path.join (work_dir, repo_name)));
}

/**
 * @param linker{linkers}  The linker to be timed.
 * @return {boolean}  True for all linkers other than rld.
 */
function needs_repo2obj (linker) {
    return linker !== linkers.rld;
}

/**
 * Accepts an array full of "tasks" (functions which take no arguments and return a promise of a
 * result). Returns a single promise of an array of results from those tasks which are executed
 * serially.
 *
 * @param tasks{Array<function>}
 * @returns {Promise<Array<*>>}
 */
function serialize_tasks (tasks) {
    return tasks.reduce ((promise_chain, item) => {
        return promise_chain.then (chain_results => item ().then (result => [...chain_results, result]));
    }, Promise.resolve ([]));
}

exports.serialize_tasks = serialize_tasks;

function on_rld_gen_stdout (data) {
    const module_number = parseInt (data, 10);
    if (lower_bar) {
        lower_bar.update (module_number + 1, {stage: 'rld-gen'});
    }
}

/**
 * @param multi_bar{cli_progress.MultiBar}
 * @param r{run.runner}  An instance of run.js/runner.
 * @param lds{timey.linkers[]}  The linkers to be timed.
 * @param num_modules{Number}  The number of modules (ticket files) to be produced.
 * @param num_external_symbols{Number}  The number of external symbols per module.
 * @param num_linkonce_symbols{Number}  The number of linkonce symbols per module.
 * @returns {Promise<number[]>}  The promise of an array of timings (one per linker in the order of the lds[] array).
 */
function single_run (multi_bar, r, lds, num_modules, num_external_symbols, num_linkonce_symbols) {
    const work_dir = r.get_work_dir ();
    const r2o_count = (lds.some (needs_repo2obj) ? 1 : 0) * num_modules;
    const count = num_modules // for rld-gen
        + lds.length
        + r2o_count;
    const bar = multi_bar ? multi_bar.create (count, 0, {stage: ''}) : null;

    let repo2obj_was_run = false;
    const get_linker_input_files = (linker, ticket_files) => {
        if (!needs_repo2obj (linker)) {
            // Just pass on the ticket files.
            return new Promise ((resolve, _) => resolve (ticket_files));
        }
        if (repo2obj_was_run) {
            // Find the object files we produced earlier.
            return glob (all_objects_pattern (r.get_work_dir ()));
        }
        // Run repo2obj to convert each ticket file to an ELF object file for input to a traditional
        // linker. Yield the list of files we created.
        return async.mapLimit (ticket_files, os.cpus ().length, function (ticket_file, callback) {
            repo2obj_was_run = true;
            if (bar) {
                bar.increment (1, {stage: 'repo2obj'});
            }
            const object_file = ticket_file + object_file_extension;
            return r.repo2obj (ticket_file, object_file)
                .then (() => {
                    callback (null, object_file);
                })
                .catch (callback);
        });
    };

    return clean_all (work_dir, r.get_repo_name ())
        //.then (() => console.log (`external=${num_external_symbols}, linkonce=${num_linkonce_symbols}`))
        .then (() => r.rld_gen (
            num_modules, num_external_symbols, num_linkonce_symbols,
            data => {
                if (bar) {
                    bar.update (parseInt (data.toString (), 10) + 1, {stage: 'rld-gen'});
                }
            })
        )
        .then (() => glob (all_tickets_pattern (work_dir)))
        .then (ticket_files => {
            // Turn each member of the array of lds (a member the linkers 'enum') into a promise
            // which will run that linker and return the time it took. The resulting array of
            // promises is then resolved in series.
            return serialize_tasks (lds.map (l => () => {
                return get_linker_input_files (l, ticket_files)
                    .then (ld_inputs => {
                        if (bar) {
                            bar.increment (1, {stage: get_key_by_value (linkers, l)});
                        }
                        const start = Date.now ();
                        return (l === linkers.rld ? r.rld : r.lld) (ld_inputs, path.join (work_dir, 'a.out'))
                            .then (() => Date.now () - start)
                            .catch (err => Promise.reject (err));
                    });
            }));
        })
        .then (x => {
            if (multi_bar) {
                multi_bar.remove (bar);
            }
            return x;
        })
        .catch (err => Promise.reject (err));
}

exports.single_run = single_run;

/**
 * Checks whether the given directory is both a directory and, unless force is true, empty. If not,
 * an error is raised.
 *
 * @param work_dir{string}  The directory to be checked.
 * @param force{boolean}  If true avoids an error if the directory is not empty.
 * @returns {Promise<boolean>}  A promise of true if the work directory is to be used, false
 * otherwise.
 */
function check_work_directory (work_dir, force) {
    return promisify (fs.stat) (work_dir)
        .then (stats => {
            if (!stats.isDirectory ()) {
                return Promise.reject (new Error ('The specified work directory is not a directory'));
            }
            return promisify (fs.readdir) (work_dir);
        })
        .then (files => {
            if (files.length > 0 && !force) {
                return Promise.reject (new Error ('The specified work directory was not empty (--force to continue anyway)'));
            }
            return true;
        });
}

exports.check_work_directory = check_work_directory;

