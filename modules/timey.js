/*eslint quotes: ["error", "single"]*/
'use strict';

const async = require ('async');
const fs = require ('fs');
const glob = require ('glob-promise');
const os = require ('os');
const path = require ('path');
const {promisify} = require ('util');

const linkers = {rld: 1, lld: 2};
Object.freeze (linkers);
exports.linkers = linkers;

/**
 * @param work_dir{string}  The directory used for intermediate files.
 * @returns {string} A glob pattern which will match the ticket files generated by rld-gen.
 */
function all_tickets_pattern (work_dir) {
    return path.join (work_dir, '*.o');
}

/**
 * Deletes the intermediate ticket, ELF, and repo database files from the working directory.
 *
 * @param work_dir{string}  The directory which will be used for intermediate files.
 * @param repo_name{string}  The name of the program repository database.
 * @returns {Promise<*>} A promise which is resolved once all of the intermediate files have been
 * deleted.
 */
function clean_all (work_dir, repo_name) {
    const clean = (pattern) => {
        return glob (pattern)
            .then ((contents) => contents.forEach (file => fs.unlinkSync (file)));
    };
    return clean (all_tickets_pattern (work_dir))
        .then (() => clean (path.join (work_dir, '*.o.elf')))
        .then (() => clean (path.join (work_dir, repo_name)));
}

/**
 * @param r{runner}  An instance of run.js/runner.
 * @param linker{linkers}  The linker to be timed.
 * @param num_modules{Number}  The number of modules (ticket files) to be produced.
 * @param num_external_symbols{Number}  The number of external symbols per module.
 * @param num_linkonce_symbols{Number}  The number of linkonce symbols per module.
 */
function single_run (r, linker, num_modules, num_external_symbols, num_linkonce_symbols) {
    const work_dir = r.get_work_dir ();
    return clean_all (work_dir, r.get_repo_name ())
        //.then (() => console.log (`external=${num_external_symbols}, linkonce=${num_linkonce_symbols}`))
        .then (() => r.rld_gen (num_modules, num_external_symbols, num_linkonce_symbols))
        .then (() => glob (all_tickets_pattern (work_dir)))
        .then (ticket_files => {
            if (linker === linkers.rld) {
                // Just pass on the ticket files.
                return ticket_files;
            }

            // Run repo2obj to convert each ticket file to an ELF object file for input to a traditional linker.
            return async.mapLimit (ticket_files, os.cpus ().length, function (ticket_file, callback) {
                const elf_file = ticket_file + '.elf';
                r.repo2obj (ticket_file, elf_file)
                    .then (() => callback (null, elf_file))
                    .catch (callback);
            });
        })
        .then (ld_inputs => {
            const start = Date.now ();
            return (linker === linkers.rld ? r.rld : r.lld) (ld_inputs, path.join (work_dir, 'a.out'))
                .then (() => Date.now () - start)
                .catch (err => { throw err; });
        });
}
exports.single_run = single_run;

/**
 * Checks whether the given directory is both a directory and, unless force is true, empty. If not,
 * an error is raised.
 *
 * @param work_dir{string}  The directory to be checked.
 * @param force{boolean}  If true avoids an error if the directory is not empty.
 * @returns {Promise<boolean>}  A promise of true if the work directory is to be used, false
 * otherwise.
 */
function check_work_directory (work_dir, force) {
    return promisify (fs.stat) (work_dir)
        .then (stats => {
            if (!stats.isDirectory ()) {
                throw new Error ('The specified work directory is not a directory');
            }
            return promisify (fs.readdir) (work_dir);
        })
        .then (files => {
            if (files.length > 0 && !force) {
                throw new Error ('The specified work directory was not empty (--force to continue anyway)');
            }
            return true;
        });
}
exports.check_work_directory = check_work_directory;

/**
 * Accepts an array full of "tasks" (functions which take no arguments and return a promise of a
 * result). Returns a single promise of an array of results from those tasks which are executed
 * serially.
 *
 * @param tasks{Array<function>}
 * @returns {Promise<Array<results>>}
 */
function serialize_tasks (tasks) {
    return tasks.reduce ((promise_chain, item) => {
        return promise_chain.then (chain_results => item ().then (result => [...chain_results, result]));
    }, Promise.resolve ([]));
}
exports.serialize_tasks = serialize_tasks;
